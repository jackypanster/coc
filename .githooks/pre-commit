#!/bin/bash

# Git pre-commit hook for version consistency validation
# 防止版本不一致问题的提交前检查

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${YELLOW}[PRE-COMMIT]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[PRE-COMMIT]${NC} $1"
}

log_error() {
    echo -e "${RED}[PRE-COMMIT]${NC} $1"
}

# 检查是否有版本相关文件的更改
check_version_related_changes() {
    local version_files=("versions.env" "Dockerfile.base" "build-base.sh" "build.sh" "build-full.sh")
    local changed_files=()
    
    for file in "${version_files[@]}"; do
        if git diff --cached --name-only | grep -q "^$file$"; then
            changed_files+=("$file")
        fi
    done
    
    if [ ${#changed_files[@]} -eq 0 ]; then
        log_info "没有版本相关文件的更改，跳过版本一致性检查"
        return 1
    fi
    
    log_info "检测到版本相关文件更改: ${changed_files[*]}"
    return 0
}

# 验证 versions.env 格式
validate_versions_env_format() {
    if [ ! -f "versions.env" ]; then
        log_error "versions.env 文件不存在"
        return 1
    fi
    
    # 检查必需变量
    local required_vars=("NODE_VERSION" "CLAUDE_CODE_VERSION" "CLAUDE_ROUTER_VERSION" "VERSION" "IMAGE_NAME")
    local missing_vars=()
    
    source ./versions.env
    
    for var in "${required_vars[@]}"; do
        if [ -z "${!var}" ]; then
            missing_vars+=("$var")
        fi
    done
    
    if [ ${#missing_vars[@]} -gt 0 ]; then
        log_error "versions.env 缺少必需变量: ${missing_vars[*]}"
        return 1
    fi
    
    # 验证版本格式
    if [[ ! $NODE_VERSION =~ ^[0-9]+$ ]]; then
        log_error "NODE_VERSION 格式错误: $NODE_VERSION (应为数字)"
        return 1
    fi
    
    if [[ ! $CLAUDE_CODE_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        log_error "CLAUDE_CODE_VERSION 格式错误: $CLAUDE_CODE_VERSION (应为 x.y.z 格式)"
        return 1
    fi
    
    if [[ ! $CLAUDE_ROUTER_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        log_error "CLAUDE_ROUTER_VERSION 格式错误: $CLAUDE_ROUTER_VERSION (应为 x.y.z 格式)"
        return 1
    fi
    
    if [[ ! $IMAGE_NAME =~ ^[a-z0-9]([a-z0-9-]*[a-z0-9])?$ ]]; then
        log_error "IMAGE_NAME 格式错误: $IMAGE_NAME (只能包含小写字母、数字和连字符)"
        return 1
    fi
    
    log_success "versions.env 格式验证通过"
    return 0
}

# 检查 Dockerfile.base 是否移除了硬编码默认值
check_dockerfile_no_defaults() {
    if [ ! -f "Dockerfile.base" ]; then
        log_error "Dockerfile.base 文件不存在"
        return 1
    fi
    
    # 检查是否有带默认值的 ARG
    local args_with_defaults=$(grep -c "ARG.*=" Dockerfile.base || true)
    
    if [ "$args_with_defaults" -gt 0 ]; then
        log_error "Dockerfile.base 包含硬编码默认值，发现 $args_with_defaults 个带默认值的 ARG"
        log_error "请移除所有 ARG 指令的默认值，确保版本通过构建参数传入"
        return 1
    fi
    
    # 检查必需的 ARG 声明
    local required_args=("NODE_VERSION" "CLAUDE_CODE_VERSION" "CLAUDE_ROUTER_VERSION")
    local missing_args=()
    
    for arg in "${required_args[@]}"; do
        if ! grep -q "ARG $arg" Dockerfile.base; then
            missing_args+=("$arg")
        fi
    done
    
    if [ ${#missing_args[@]} -gt 0 ]; then
        log_error "Dockerfile.base 缺少必需的 ARG 声明: ${missing_args[*]}"
        return 1
    fi
    
    log_success "Dockerfile.base 检查通过"
    return 0
}

# 验证构建脚本语法
validate_build_scripts_syntax() {
    local scripts=("build-base.sh" "build.sh" "build-full.sh")
    local failed_scripts=()
    
    for script in "${scripts[@]}"; do
        if [ -f "$script" ]; then
            if ! bash -n "$script"; then
                failed_scripts+=("$script")
            fi
        fi
    done
    
    if [ ${#failed_scripts[@]} -gt 0 ]; then
        log_error "以下构建脚本语法错误: ${failed_scripts[*]}"
        return 1
    fi
    
    log_success "构建脚本语法验证通过"
    return 0
}

# 运行快速版本一致性检查
run_quick_version_check() {
    log_info "运行快速版本一致性检查..."
    
    # 检查构建脚本是否正确加载版本配置
    local scripts=("build-base.sh" "build.sh" "build-full.sh")
    
    for script in "${scripts[@]}"; do
        if [ -f "$script" ]; then
            if ! grep -q "source.*versions.env" "$script"; then
                log_error "$script 未正确加载 versions.env"
                return 1
            fi
        fi
    done
    
    # 检查 build-base.sh 是否包含版本验证逻辑
    if [ -f "build-base.sh" ]; then
        if ! grep -q "validate_all_versions" build-base.sh; then
            log_error "build-base.sh 缺少版本验证逻辑"
            return 1
        fi
    fi
    
    log_success "快速版本一致性检查通过"
    return 0
}

# 主函数
main() {
    log_info "开始版本一致性预提交检查..."
    
    # 检查是否有版本相关文件的更改
    if ! check_version_related_changes; then
        exit 0
    fi
    
    local check_failed=0
    
    # 1. 验证 versions.env 格式
    if ! validate_versions_env_format; then
        check_failed=1
    fi
    
    # 2. 检查 Dockerfile.base
    if ! check_dockerfile_no_defaults; then
        check_failed=1
    fi
    
    # 3. 验证构建脚本语法
    if ! validate_build_scripts_syntax; then
        check_failed=1
    fi
    
    # 4. 运行快速版本检查
    if ! run_quick_version_check; then
        check_failed=1
    fi
    
    if [ $check_failed -eq 1 ]; then
        echo ""
        log_error "❌ 版本一致性检查失败！"
        log_error "请修复上述问题后重新提交"
        echo ""
        log_info "💡 提示："
        log_info "   - 运行 ./test-version-consistency.sh 进行完整测试"
        log_info "   - 检查 versions.env 文件格式是否正确"
        log_info "   - 确保 Dockerfile.base 移除了硬编码默认值"
        log_info "   - 验证所有构建脚本语法正确"
        echo ""
        exit 1
    fi
    
    log_success "✅ 版本一致性预提交检查通过！"
    exit 0
}

# 运行主函数
main "$@"